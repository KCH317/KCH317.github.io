# 4차 과제
- 2020250001
- 권찬호

기본 설정
- 필수 모듈 불러오기
- 그래프 출력 관련 기본 설정 지정


```python
# 파이썬 ≥3.5 필수
import sys
assert sys.version_info >= (3, 5)

# 사이킷런 ≥0.20 필수
import sklearn
assert sklearn.__version__ >= "0.20"


# 공통 모듈 임포트
import numpy as np
import os

# 노트북 실행 결과를 동일하게 유지하기 위해
np.random.seed(42)

# 깔끔한 그래프 출력을 위해
%matplotlib inline
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rc('axes', labelsize=14)
mpl.rc('xtick', labelsize=12)
mpl.rc('ytick', labelsize=12)

# 그림을 저장할 위치
PROJECT_ROOT_DIR = "."
CHAPTER_ID = "training_linear_models"
IMAGES_PATH = os.path.join(PROJECT_ROOT_DIR, "images", CHAPTER_ID)
os.makedirs(IMAGES_PATH, exist_ok=True)

def save_fig(fig_id, tight_layout=True, fig_extension="png", resolution=300):
    path = os.path.join(IMAGES_PATH, fig_id + "." + fig_extension)
    print("그림 저장:", fig_id)
    if tight_layout:
        plt.tight_layout()
    plt.savefig(path, format=fig_extension, dpi=resolution)
    
# 어레이 데이터를 csv 파일로 저장하기
def save_data(fileName, arrayName, header=''):
    np.savetxt(fileName, arrayName, delimiter=',', header=header, comments='')
```


```python
from sklearn import datasets
iris = datasets.load_iris()
```

# 과제 1
조기 종료를 사용한 배치 경사 하강법으로 로지스틱 회귀를 구현하라. 

단, 사이킷런을 전혀 사용하지 않아야 한다.

## 단계 1: 데이터 준비

붓꽃 데이터셋의 꽃잎 길이(petal length)와 꽃잎 너비(petal width) 특성만 이용한다.


```python
X = iris["data"][:, (2, 3)]  # 꽃잎 길이, 꽃잎 넓이
y = iris["target"]
```

모든 샘플에 편향 추가

- np_c로 column으로 이어 붙임


```python
X_with_bias = np.c_[np.ones([len(X), 1]), X]
```

일정한 결과를 만들어내기 위해 랜덤시드를 고정적으로 줌


```python
np.random.seed(2042)
```

## 단계 2: 데이터셋 분할

사이킷런의 train_test_split() 함수를 사용하지 않고 수동으로 무작위 분할


```python
test_ratio = 0.2                                         # 테스트 세트 비율 = 20%
validation_ratio = 0.2                                   # 검증 세트 비율 = 20%
total_size = len(X_with_bias)                            # 전체 데이터셋 크기

test_size = int(total_size * test_ratio)                 # 테스트 세트 크기: 전체의 20%
validation_size = int(total_size * validation_ratio)     # 검증 세트 크기: 전체의 20%
train_size = total_size - test_size - validation_size    # 훈련 세트 크기: 전체의 60%
```

np.random.permutation() 함수를 이용하여 인덱스를 무작위로 섞는다.


```python
rnd_indices = np.random.permutation(total_size)
```

인덱스가 무작위로 섞였기 때문에 무작위로 분할하는 효과를 얻는다. 방법은 섞인 인덱스를 이용하여 지정된 6:2:2의 비율로 훈련, 검증, 테스트 세트로 분할하는 것이다.


```python
X_train = X_with_bias[rnd_indices[:train_size]]
y_train = y[rnd_indices[:train_size]]

X_valid = X_with_bias[rnd_indices[train_size:-test_size]]
y_valid = y[rnd_indices[train_size:-test_size]]

X_test = X_with_bias[rnd_indices[-test_size:]]
y_test = y[rnd_indices[-test_size:]]
```

## 단계 3: 타깃 변환

타깃은 0, 1, 2로 설정되어 있다. 차례대로 세토사, 버시컬러, 버지니카 품종을 가리킨다. 훈련 세트의 첫 5개 샘플의 품종은 다음과 같다.


```python
y_train[:5]
```




    array([0, 1, 2, 1, 1])



원-핫 벡터 설정


```python
def to_one_hot(y):
    n_classes = y.max() + 1                 # 클래스 수
    m = len(y)                              # 샘플 수
    Y_one_hot = np.zeros((m, n_classes))    # (샘플 수, 클래스 수) 0-벡터 생성
    Y_one_hot[np.arange(m), y] = 1          # 샘플 별로 해당 클래스의 값만 1로 변경. (넘파이 인덱싱 활용)
    return Y_one_hot
```

원-핫 벡터에 대한 테스트입니다


```python
to_one_hot(y_train[:5])
```




    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.],
           [0., 1., 0.],
           [0., 1., 0.]])




```python
Y_train_one_hot = to_one_hot(y_train)
Y_valid_one_hot = to_one_hot(y_valid)
Y_test_one_hot = to_one_hot(y_test)
```

## 단계 4: 로지스틱 회귀 함수구현


```python
def logistic(z):
    return 1/(1 + np.exp(-z))
```

## 단계 5: 경사하강법 활용 훈련

경사하강법을 구현하기 위해 아래 비용함수와 비용함수의 그레이디언트를 파이썬으로 구현할 수 있어야 한다


```python
n_inputs = X_train.shape[1]           # 특성 수(n) + 1, 붓꽃의 경우: 특성 2개 + 1
n_outputs = len(np.unique(y_train))   # 중복을 제거한 클래스 수(K), 붓꽃의 경우: 3개
```

파라미터 
Θ
를 무작위로 초기 설정한다.


```python
Theta = np.random.randn(n_inputs, n_outputs)
```

배치 경사하강법 훈련은 아래 코드를 통해 이루어진다.

- eta = 0.01: 학습률
- n_iterations = 5001 : 에포크 수
- m = len(X_train): 훈련 세트 크기, 즉 훈련 샘플 수
- epsilon = 1e-7: 
log
 값이 항상 계산되도록 더해지는 작은 실수
- logits: 모든 샘플에 대한 클래스별 점수, 즉 
X
train
Θ
- Y_proba: 모든 샘플에 대해 계산된 클래스 별 소속 확률, 즉 
^
P


```python
#  배치 경사하강법 구현
eta = 0.01
n_iterations = 5001
m = len(X_train)
epsilon = 1e-7

for iteration in range(n_iterations):     # 5001번 반복 훈련
    logits = X_train.dot(Theta)
    Y_proba = logistic(logits)
    
    if iteration % 500 == 0:              # 500 에포크마다 손실(비용) 계산해서 출력
        loss = -np.mean(np.sum(Y_train_one_hot * np.log(Y_proba + epsilon), axis=1))
        print(iteration, loss)
    
    error = Y_proba - Y_train_one_hot     # 그레이디언트 계산.
    gradients = 1/m * X_train.T.dot(error)
    
    Theta = Theta - eta * gradients       # 파라미터 업데이트
```

    0 2.879452675764795
    500 0.8411619643205543
    1000 0.7441758613299106
    1500 0.6805538946495453
    2000 0.6368494302871641
    2500 0.6053324972843511
    3000 0.5815889410900722
    3500 0.5630243067213745
    4000 0.548053181656526
    4500 0.5356676834673233
    5000 0.5252029776033043


학습된 파라미터는 다음과 같다.


```python
Theta
```




    array([[ 3.64527907, -1.43720859, -3.65909431],
           [-1.23421557,  0.22083091,  0.21368026],
           [-0.86364788, -0.08601454,  1.6308143 ]])



검증 세트에 대한 예측과 정확도는 다음과 같다. logits, Y_proba를 검증 세트인 X_valid를 이용하여 계산한다. 예측 클래스는 Y_proba에서 가장 큰 값을 갖는 인덱스로 선택한다.


```python
logits = X_valid.dot(Theta)              
Y_proba = logistic(logits)
y_predict = np.argmax(Y_proba, axis=1)          # 가장 높은 확률을 갖는 클래스 선택

accuracy_score = np.mean(y_predict == y_valid)  # 정확도 계산
accuracy_score
```




    0.9



## 단계 6: 규제가 추가된 경사하강법 활용 훈련

ℓ
2
 규제가 추가된 경사하강법 훈련을 구현한다. 코드는 기본적으로 동일하다. 다만 손실(비용)에 
ℓ
2
 페널티가 추가되었고 그래디언트에도 항이 추가되었다(Theta의 첫 번째 원소는 편향이므로 규제하지 않습니다).

- 학습률 eta 증가됨.
- alpha = 0.1: 규제 강도


```python
eta = 0.1
n_iterations = 5001
m = len(X_train)
epsilon = 1e-7
alpha = 0.1        # 규제 하이퍼파라미터

Theta = np.random.randn(n_inputs, n_outputs)  # 파라미터 새로 초기화

for iteration in range(n_iterations):
    logits = X_train.dot(Theta)
    Y_proba = logistic(logits)
    
    if iteration % 500 == 0:
        xentropy_loss = -np.mean(np.sum(Y_train_one_hot * np.log(Y_proba + epsilon), axis=1))
        l2_loss = 1/2 * np.sum(np.square(Theta[1:]))  # 편향은 규제에서 제외
        loss = xentropy_loss + alpha * l2_loss        # l2 규제가 추가된 손실
        print(iteration, loss)
    
    error = Y_proba - Y_train_one_hot
    l2_loss_gradients = np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]   # l2 규제 그레이디언트
    gradients = 1/m * X_train.T.dot(error) + l2_loss_gradients
    
    Theta = Theta - eta * gradients
```

    0 0.5672411342787836
    500 0.660797114029667
    1000 0.6648760638738773
    1500 0.6716657187332781
    2000 0.6764787280572263
    2500 0.6797981643157118
    3000 0.6820813210563802
    3500 0.6836476574493875
    4000 0.6847196389348427
    4500 0.6854519243996793
    5000 0.6859514895832416


패널티를 주자 오히려 정확도가 낮아진 것을 확인할 수 있습니다.

제 생각에는 데이터셋의 수가 너무 적어서 그런 것이라고 생각됩니다.

0.9 -> 0.83


```python
logits = X_valid.dot(Theta)
Y_proba = logistic(logits)
y_predict = np.argmax(Y_proba, axis=1)

accuracy_score = np.mean(y_predict == y_valid)
accuracy_score
```




    0.8333333333333334



## 단계 7: 조기종료 추가

위 규제가 사용된 모델의 훈련 과정에서 매 에포크마다 검증 세트에 대한 손실을 계산하여 오차가 줄어들다가 증가하기 시작할 때 멈추도록 한다.


```python
eta = 0.1 
n_iterations = 5001
m = len(X_train)
epsilon = 1e-7
alpha = 0.1            # 규제 하이퍼파라미터
best_loss = np.infty   # 최소 손실값 기억 변수

Theta = np.random.randn(n_inputs, n_outputs)  # 파라미터 새로 초기화

for iteration in range(n_iterations):
    # 훈련 및 손실 계산
    logits = X_train.dot(Theta)
    Y_proba = logistic(logits)
    error = Y_proba - Y_train_one_hot
    gradients = 1/m * X_train.T.dot(error) + np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]
    Theta = Theta - eta * gradients

    # 검증 세트에 대한 손실 계산
    logits = X_valid.dot(Theta)
    Y_proba = logistic(logits)
    xentropy_loss = -np.mean(np.sum(Y_valid_one_hot * np.log(Y_proba + epsilon), axis=1))
    l2_loss = 1/2 * np.sum(np.square(Theta[1:]))
    loss = xentropy_loss + alpha * l2_loss
    
    # 500 에포크마다 검증 세트에 대한 손실 출력
    if iteration % 500 == 0:
        print(iteration, loss)
        
    # 에포크마다 최소 손실값 업데이트
    if loss < best_loss:
        best_loss = loss
    else:                                      # 에포크가 줄어들지 않으면 바로 훈련 종료
        print(iteration - 1, best_loss)        # 종료되지 이전 에포크의 손실값 출력
        print(iteration, loss, "조기 종료!")
        break
```

    0 1.5605646999042637
    6 0.8770382719242104
    7 0.901904994443427 조기 종료!


훈련이 조기 종료 되었지만 검증 세트에 대한 정확도가 0.33으로 확 낮아졌습니다.

최적점을 찾기 전에 종료된 것 같습니다.


```python
logits = X_valid.dot(Theta)
Y_proba = logistic(logits)
y_predict = np.argmax(Y_proba, axis=1)

accuracy_score = np.mean(y_predict == y_valid)
accuracy_score
```




    0.3333333333333333



## 단계 8: 테스트 세트 평가

마지막으로 테스트 세트에 대한 모델의 최종 성능을 정확도로 측정한다.

조기종료를 설정한 이후에 정확도가 0.9 -> 0.33으로 낮아졌습니다.


```python
logits = X_test.dot(Theta)
Y_proba = logistic(logits)
y_predict = np.argmax(Y_proba, axis=1)

accuracy_score = np.mean(y_predict == y_test)
accuracy_score
```




    0.3333333333333333



# 과제 2

과제 1에서 구현된 로지스틱 회귀 알고리즘에 일대다(OvR) 방식을 적용하여 붓꽃에 대한 다중 클래스 분류 알고리즘을 구현하라. 단, 사이킷런을 전혀 사용하지 않아야 한다.

## 단계 1: 데이터 준비

붓꽃 데이터셋의 꽃잎 길이(petal length)와 꽃잎 너비(petal width) 특성만 이용한다.


```python
X = iris["data"][:, (2, 3)]  # 꽃잎 길이, 꽃잎 넓이
y = iris["target"]
```

모든 샘플에 편향 추가

- np_c로 column으로 이어 붙임


```python
X_with_bias = np.c_[np.ones([len(X), 1]), X]
```

일정한 결과를 만들어내기 위해 랜덤시드를 고정적으로 줌


```python
np.random.seed(2042)
```

## 단계 2: 데이터셋 분할

사이킷런의 train_test_split() 함수를 사용하지 않고 수동으로 무작위 분할


```python
test_ratio = 0.2                                         # 테스트 세트 비율 = 20%
validation_ratio = 0.2                                   # 검증 세트 비율 = 20%
total_size = len(X_with_bias)                            # 전체 데이터셋 크기

test_size = int(total_size * test_ratio)                 # 테스트 세트 크기: 전체의 20%
validation_size = int(total_size * validation_ratio)     # 검증 세트 크기: 전체의 20%
train_size = total_size - test_size - validation_size    # 훈련 세트 크기: 전체의 60%
```

np.random.permutation() 함수를 이용하여 인덱스를 무작위로 섞는다.


```python
rnd_indices = np.random.permutation(total_size)
```

인덱스가 무작위로 섞였기 때문에 무작위로 분할하는 효과를 얻는다. 방법은 섞인 인덱스를 이용하여 지정된 6:2:2의 비율로 훈련, 검증, 테스트 세트로 분할하는 것이다.


```python
X_train = X_with_bias[rnd_indices[:train_size]]
y_train = y[rnd_indices[:train_size]]

X_valid = X_with_bias[rnd_indices[train_size:-test_size]]
y_valid = y[rnd_indices[train_size:-test_size]]

X_test = X_with_bias[rnd_indices[-test_size:]]
y_test = y[rnd_indices[-test_size:]]
```

## 단계 3: 타깃 변환

- 원-핫 벡터 설정


```python
def to_one_hot(y):
    n_classes = y.max() + 1                 # 클래스 수
    m = len(y)                              # 샘플 수
    Y_one_hot = np.zeros((m, n_classes))    # (샘플 수, 클래스 수) 0-벡터 생성
    Y_one_hot[np.arange(m), y] = 1          # 샘플 별로 해당 클래스의 값만 1로 변경. (넘파이 인덱싱 활용)
    return Y_one_hot
```

## 단계 4: 로지스틱 회귀 함수 OVR방식으로 구현
- 다음은 OVR로 변경한 로지스틱 회귀 함수입니다.
![스크린샷 2021-05-02 오전 1.55.29.png](data:image/png;base64,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c92bb77ZnXLKKd0555zTffSjH+308X/+53+6999/v9U1qiE777xzt8suu7Q6PvKRj2yv549//GN3++23d/fee2/37rvvdlu2bOkuvPDC1t/cc0ZFN/sFgSAQBILAWiLgPnzFFVd0V111VVf31FHb22npgBCwUdHKfkEgCASBFRBAkPwYWyM0n/jEJ2bygKoI0q9//evu1Vdf7Z566qm2PuCAA7ovfvGL3eGHH97ttttujbysYNr2j6uuInOIDuL429/+thGrJ554ohExhOq0007rjjnmmO6www5r/Xrttde6e+65p3vxxRdb/44++uju5JNPbsQPiUIO1YuEjVLY4jjE6+Mf/3j3sY99rEPI1IF0IWDaU28RMH0OARsF3ewTBIJAEAgCa41ACNhaI5z6g0AQCAIjINB/njUr5QuZQ0IoT48++mhT2KhOlKmDDjpoZPLFfHUhOFS6d955pyl2r7zySvf88893zzzzTFsQoi984Qvd9773vQ7J2nfffdt+iNedd97Z1DGffe5zn2v7fepTn2rk6e233271InWj9J0tyNQee+zRIVYiKrRd/S0Chox96Utf6i666KK2XyllIwxHdgkCQSAIBIEgsGYIhICtGbSpOAgEgSCwfghQk373u99127Zta+Tr/vvvb6QFWUGSPvnJTzbVaFQL1SdUsFQvpEm44csvv9zZ1pZ6jz322O7iiy/uDj300KZO2YcNt912W1PftI+AUaaskSjHqxdhUoaRMETVgoAJndx///27Pffcs5FDapxwR+GHDz/8cLMX0Tz77LO7z3/+850w+FLMRu139gsCQSAIBIEgMGsEQsBmjWjqCwJBIAjMAQLIEvKDiDzwwAPdfffd1+Z7ISxICDWoyMwo5lKX1NkPPRTaiDwpCNFxxx3X5nchPOaxCRMUfvjCCy90d9xxR0cxQ5qQoYMPPrgRtr322quFMboZqX+Uwm5KnvBJhM4aAdTfX/3qV9vnuqmPQkbxo4QhY4jnuHPeRrEp+wSBIBAEgkAQGBWBELBRkcp+QSAIBIENhADygSCZm0WBEgaIdCEu5kuNW4qsWSNjFLGat6U+9ZpXhliZ+4XoULIQI6qU+WfW9j3wwAOb+oU8IYNsVadllMIG9VQSDsdUO+a6IXpvvPFGq4/ChnhJOoKMUcu0mRIEgkAQCAJBYL0QCAFbL+TTbhAIAkFgDRFAkIT1ISOImLlbPkNyikyN03yFBVojP7W2XWRIiB9SZZ6XxBgKckU1k/2QPdpHzmRftA9SOG3RL20gYeanacf/+okYUrwQL2obtaxsm7bdHB8EgkAQCAJBYBIEQsAmQS3HBIEgEATmHIEiWX11yWdV+tv12WrrImG1X/9/2xSpWuq7soNaVgpXf5/ar+qcdK1uCzKmzWpL/UUSaz2rNie1NccFgSAQBILAYiMQArbY45/eB4EgEASCQBAIAkEgCASBILADEQgB24Fgp6kgEASCQBAIAkEgCASBIBAEFhuBELDFHv/0PggEgSAQBIJAEAgCQSAIBIEdiEAI2A4EO00FgSAQBILA9AiY45V5XNPjmBqCQBAIAkFgfRAIAVsf3NNqEAgCQSAIjIlAJfSow5CwELFCI+sgEASCQBDYKAiEgG2UkYqdQSAIBIEFQgDZUmotq6E0825a7733XnuXl3T20tjLqpgSBIJAEAgCQWCjIBACtlFGKnYGgSAQBBYIAcSrUsvrtnT6v/zlL7vXXnut+81vftNerOyFz16qnPd6LdCJka4GgSAQBDYBAiFgm2AQ04UgEASCwGZBAPHyzjAk66233upef/317t13323LCy+80L399tutq0ceeWR32mmndZ/4xCcaCdss/U8/gkAQCAJBYPMjEAK2+cc4PQwCQSAIbBgEqF4I18svv9whXE8//XT329/+tvv973/fbdu2rW0jXcjXhRde2AlD3H333TdM/2JoEAgCQSAIBIEQsJwDQSAIBIEgMDcIUMDM8XrzzTe7V155pYUdUsMoX4899lj3xhtvdHvttVd3xhlndBdffHHbFoaYEgSCQBAIAkFgoyAQArZRRip2BoEgEAQWAAEE7P33328JN955551GvBAwoYh33nln9+KLL3Z77LFHI2CXXHJJt+eeeyYEcQHOi3QxCASBILCZEAgB20yjmb4EgSAQBDYBAv0EHMgYIvbqq692119/ffeLX/yi23nnnbtTTz21u/TSS0PANsF4pwtBIAgEgUVDIARs0UY8/Q0CQSAIbDAEKGDmhF177bXd448/3t79FQK2wQYx5gaBIBAEgsB2BELAtkORjSAQBCgPlip50W0hkfV6ImD+lxT0pYA5LyXhiAK2nqOStoNAEAgCQWBSBELAJkUuxwWBTYiA9N9+FLxzybZsc7vttlsL+dqE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)


```python
def logistic_ova(z):
    return 1/(1 + np.sum(np.exp(-z), axis=1, keepdims=True))
```

## 단계 5: 경사하강법 활용 훈련

경사하강법을 구현하기 위해 아래 비용함수와 비용함수의 그레이디언트를 파이썬으로 구현할 수 있어야 한다


```python
n_inputs = X_train.shape[1]           # 특성 수(n) + 1, 붓꽃의 경우: 특성 2개 + 1
n_outputs = len(np.unique(y_train))   # 중복을 제거한 클래스 수(K), 붓꽃의 경우: 3개
```

파라미터 
Θ
를 무작위로 초기 설정한다.


```python
Theta = np.random.randn(n_inputs, n_outputs)
```

배치 경사하강법 훈련은 아래 코드를 통해 이루어진다.

- eta = 0.01: 학습률
- n_iterations = 5001 : 에포크 수
- m = len(X_train): 훈련 세트 크기, 즉 훈련 샘플 수
- epsilon = 1e-7: 
log
 값이 항상 계산되도록 더해지는 작은 실수
- logits: 모든 샘플에 대한 클래스별 점수, 즉 
X
train
Θ
- Y_proba: 모든 샘플에 대해 계산된 클래스 별 소속 확률, 즉 
^
P


```python
#  배치 경사하강법 구현
eta = 0.01
n_iterations = 5001
m = len(X_train)
epsilon = 1e-7

for iteration in range(n_iterations):     # 5001번 반복 훈련
    logits = X_train.dot(Theta)
    Y_proba = logistic_ova(logits)
    
    if iteration % 500 == 0:              # 500 에포크마다 손실(비용) 계산해서 출력
        loss = -np.mean(np.sum(Y_train_one_hot * np.log(Y_proba + epsilon), axis=1))
        print(iteration, loss)
    
    error = Y_proba - Y_train_one_hot     # 그레이디언트 계산.
    gradients = 1/m * X_train.T.dot(error)
    
    Theta = Theta - eta * gradients       # 파라미터 업데이트
```

    0 4.146421045186011
    500 1.8536690748460598
    1000 1.9358114808897353
    1500 2.0357196821411017
    2000 2.143026881579718
    2500 2.2497241405024933
    3000 2.352359345111357
    3500 2.449656711289331
    4000 2.541341846346695
    4500 2.62758483107605
    5000 2.7087374696191002


학습된 파라미터 확인


```python
Theta
```




    array([[ 3.66632604,  2.20716555,  2.78961291],
           [-1.23968851, 42.50180777, 66.01097516],
           [-0.868569  , 16.13966679, 26.75716348]])



검증 세트에 대한 예측과 정확도는 다음과 같다. logits, Y_proba를 검증 세트인 X_valid를 이용하여 계산한다. 예측 클래스는 Y_proba에서 가장 큰 값을 갖는 인덱스로 선택한다.

- ovr 방식은 정확도가 매우 낮아진것을 확인할 수 있습니다.
- 0.9 -> 0.3


```python
logits = X_valid.dot(Theta)              
Y_proba = logistic_ova(logits)
y_predict = np.argmax(Y_proba, axis=1)          # 가장 높은 확률을 갖는 클래스 선택

accuracy_score = np.mean(y_predict == y_valid)  # 정확도 계산
accuracy_score
```




    0.3



## 단계 6: 규제가 추가된 경사하강법 활용 훈련

ℓ
2
 규제가 추가된 경사하강법 훈련을 구현한다. 코드는 기본적으로 동일하다. 다만 손실(비용)에 
ℓ
2
 페널티가 추가되었고 그래디언트에도 항이 추가되었다(Theta의 첫 번째 원소는 편향이므로 규제하지 않습니다).

- 학습률 eta 증가됨.
- alpha = 0.1: 규제 강도


```python
eta = 0.1
n_iterations = 5001
m = len(X_train)
epsilon = 1e-7
alpha = 0.1        # 규제 하이퍼파라미터

Theta = np.random.randn(n_inputs, n_outputs)  # 파라미터 새로 초기화

for iteration in range(n_iterations):
    logits = X_train.dot(Theta)
    Y_proba = logistic_ova(logits)
    
    if iteration % 500 == 0:
        xentropy_loss = -np.mean(np.sum(Y_train_one_hot * np.log(Y_proba + epsilon), axis=1))
        l2_loss = 1/2 * np.sum(np.square(Theta[1:]))  # 편향은 규제에서 제외
        loss = xentropy_loss + alpha * l2_loss        # l2 규제가 추가된 손실
        print(iteration, loss)
    
    error = Y_proba - Y_train_one_hot
    l2_loss_gradients = np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]   # l2 규제 그레이디언트
    gradients = 1/m * X_train.T.dot(error) + l2_loss_gradients
    
    Theta = Theta - eta * gradients
```

    0 0.7816380524860083
    500 14.968936635696323
    1000 14.961905152184633
    1500 14.897516323526496
    2000 14.875446050550398
    2500 14.867712598978539
    3000 14.864707204351946
    3500 14.86273557861303
    4000 14.859302216300033
    4500 14.850165266817834
    5000 14.825718008979504


패널티를 주었지만 결과는 같게 나왔습니다.

0.3


```python
logits = X_valid.dot(Theta)
Y_proba = logistic_ova(logits)
y_predict = np.argmax(Y_proba, axis=1)

accuracy_score = np.mean(y_predict == y_valid)
accuracy_score
```




    0.3



## 단계 7: 조기종료 추가

위 규제가 사용된 모델의 훈련 과정에서 매 에포크마다 검증 세트에 대한 손실을 계산하여 오차가 줄어들다가 증가하기 시작할 때 멈추도록 한다.


```python
eta = 0.1 
n_iterations = 5001
m = len(X_train)
epsilon = 1e-7
alpha = 0.1            # 규제 하이퍼파라미터
best_loss = np.infty   # 최소 손실값 기억 변수

Theta = np.random.randn(n_inputs, n_outputs)  # 파라미터 새로 초기화

for iteration in range(n_iterations):
    # 훈련 및 손실 계산
    logits = X_train.dot(Theta)
    Y_proba = logistic_ova(logits)
    error = Y_proba - Y_train_one_hot
    gradients = 1/m * X_train.T.dot(error) + np.r_[np.zeros([1, n_outputs]), alpha * Theta[1:]]
    Theta = Theta - eta * gradients

    # 검증 세트에 대한 손실 계산
    logits = X_valid.dot(Theta)
    Y_proba = logistic_ova(logits)
    xentropy_loss = -np.mean(np.sum(Y_valid_one_hot * np.log(Y_proba + epsilon), axis=1))
    l2_loss = 1/2 * np.sum(np.square(Theta[1:]))
    loss = xentropy_loss + alpha * l2_loss
    
    # 500 에포크마다 검증 세트에 대한 손실 출력
    if iteration % 500 == 0:
        print(iteration, loss)
        
    # 에포크마다 최소 손실값 업데이트
    if loss < best_loss:
        best_loss = loss
    else:                                      # 에포크가 줄어들지 않으면 바로 훈련 종료
        print(iteration - 1, best_loss)        # 종료되지 이전 에포크의 손실값 출력
        print(iteration, loss, "조기 종료!")
        break
```

    0 3.1705816920804852
    6 1.832063991235183
    7 1.8580217418249976 조기 종료!


훈련이 조기 종료 되었지만 검증 세트에 대한 정확도는 여전히 0.3이다.


```python
logits = X_valid.dot(Theta)
Y_proba = logistic_ova(logits)
y_predict = np.argmax(Y_proba, axis=1)

accuracy_score = np.mean(y_predict == y_valid)
accuracy_score
```




    0.3



## 단계 8: 테스트 세트 평가

마지막으로 테스트 세트에 대한 모델의 최종 성능을 정확도로 측정한다.

- 결과적으로는 과제 1과 같은 정확도가 나왔습니다. 하지만 조기종료를 적용하기 전까지는 과제1에서 정확도가 훨씬 높게 나왔습니다.


```python
logits = X_test.dot(Theta)
Y_proba = logistic_ova(logits)
y_predict = np.argmax(Y_proba, axis=1)

accuracy_score = np.mean(y_predict == y_test)
accuracy_score
```




    0.3333333333333333



# 과제 3
A. 사진을 낮과 밤으로 분류하는 로지스틱 회귀 모델을 구현하라.

B. 사진을 낮과 밤, 실내와 실외로 분류하는 다중 레이블 분류 모델을 두 개의 로지스틱 회귀 모델을 이용하여 구현하라.

C. 과제 1에서 구현한 자신의 알고리즘과 사이킷런에서 제공하는 LogisticRegression 모델의 성능을 비교하라.

단, 모델 구현에 필요한 사진을 직접 구해야 한다. 최소 100장 이상의 사진 활용해야 한다.

**과제3 기본준비**


```python
from random import shuffle 
from tqdm import tqdm 
from PIL import Image
import warnings
warnings.filterwarnings('ignore')
import cv2
```

### A. 사진을 낮과 밤으로 분류하는 로지스틱 회귀 모델을 구현하라.

**훈련데이터 불러오기**
- 깃허브에 사진을 올려놓았습니다.
- 낮과 밤 사진 모두 200장씩 준비했습니다.


```python
!git clone https://github.com/KCH317/ML4_pitures.git
```

    Cloning into 'ML4_pitures'...
    remote: Enumerating objects: 426, done.[K
    remote: Counting objects: 100% (3/3), done.[K
    remote: Compressing objects: 100% (3/3), done.[K
    remote: Total 426 (delta 0), reused 1 (delta 0), pack-reused 423[K
    Receiving objects: 100% (426/426), 432.64 MiB | 40.40 MiB/s, done.
    Resolving deltas: 100% (3/3), done.
    Checking out files: 100% (399/399), done.


성공적으로 불러들였는지 확인 (day-night 폴더)


```python
!ls # ML4_pitures 확인
```

    images	ML4_pitures  sample_data


이미지 파일 확인


```python
import os
```


```python
Image.open("/content/ML4_pitures/day_train/Image00001.jpg")
```




    
![png](output_94_0.png)
    




```python
Image.open("/content/ML4_pitures/night_train/Image00001.jpg")
```




    
![png](output_95_0.png)
    



사진 경로 설정


```python
train_day = "/content/ML4_pitures/day_train"
train_night = "/content/ML4_pitures/night_train"
test_day = "/content/ML4_pitures/day_test"
test_night = "/content/ML4_pitures/night_test"
image_size = 128
```

이미지를 분석하기 좋게 변경합니다.


```python
for image in tqdm(os.listdir(train_day)): 
    path = os.path.join(train_day, image)
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
    img = cv2.resize(img, (image_size, image_size)).flatten()   
    np_img=np.asarray(img)
    
for image2 in tqdm(os.listdir(train_night)): 
    path = os.path.join(train_night, image2)
    img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
    img2 = cv2.resize(img2, (image_size, image_size)).flatten() 
    np_img2=np.asarray(img2)

plt.figure(figsize=(10,10))
plt.subplot(1, 2, 1)
plt.imshow(np_img.reshape(image_size, image_size))
plt.axis('off')
plt.subplot(1, 2, 2)
plt.imshow(np_img2.reshape(image_size, image_size))
plt.axis('off')
```

    100%|██████████| 50/50 [00:00<00:00, 507.64it/s]
    100%|██████████| 50/50 [00:00<00:00, 863.74it/s]





    (-0.5, 127.5, 127.5, -0.5)




    
![png](output_99_2.png)
    


훈련데이터를 만드는 함수


```python
def train_data():
    train_data_daytime = [] 
    train_data_night = []
    for image1 in tqdm(os.listdir(train_day)): 
        path = os.path.join(train_day, image1)
        img1 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img1 = cv2.resize(img1, (image_size, image_size))
        train_data_daytime.append(img1) 
    for image2 in tqdm(os.listdir(train_night)): 
        path = os.path.join(train_night, image2)
        img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img2 = cv2.resize(img2, (image_size, image_size))
        train_data_night.append(img2) 
    
    train_data= np.concatenate((np.asarray(train_data_daytime),np.asarray(train_data_night)),axis=0)
    return train_data 
```

테스트데이터를 만드는 함수


```python
def test_data():
    test_data_daytime = [] 
    test_data_night = []
    for image1 in tqdm(os.listdir(test_day)): 
        path = os.path.join(test_day, image1)
        img1 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img1 = cv2.resize(img1, (image_size, image_size))
        test_data_daytime.append(img1) 
    for image2 in tqdm(os.listdir(test_night)): 
        path = os.path.join(test_night, image2)
        img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img2 = cv2.resize(img2, (image_size, image_size))
        test_data_night.append(img2) 
    
    test_data= np.concatenate((np.asarray(test_data_daytime),np.asarray(test_data_night)),axis=0) 
    return test_data 
```

훈련데이터, 테스트데이터
- train_data
- test_data


```python
train_data = train_data() 
test_data = test_data()
```

    100%|██████████| 50/50 [00:00<00:00, 634.09it/s]
    100%|██████████| 50/50 [00:00<00:00, 677.30it/s]
    100%|██████████| 50/50 [00:00<00:00, 777.03it/s]
    100%|██████████| 50/50 [00:00<00:00, 835.41it/s]


x_data : 정규화한 데이터


```python
x_data=np.concatenate((train_data,test_data),axis=0)
x_data = (x_data-np.min(x_data))/(np.max(x_data)-np.min(x_data))
```


```python
z1 = np.zeros(80)
o1 = np.ones(80)
Y_train = np.concatenate((o1, z1), axis=0)
z = np.zeros(20)
o = np.ones(20)
Y_test = np.concatenate((o, z), axis=0)
```


```python
y_data=np.concatenate((Y_train,Y_test),axis=0).reshape(x_data.shape[0],1)
```


```python
print("X shape: " , x_data.shape)
print("Y shape: " , y_data.shape)
```

    X shape:  (200, 128, 128)
    Y shape:  (200, 1)


train_test_split


```python
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.15, random_state=42)
number_of_train = x_train.shape[0]
number_of_test = x_test.shape[0]
```


```python
x_train_flatten = x_train.reshape(number_of_train,x_train.shape[1]*x_train.shape[2])
x_test_flatten = x_test .reshape(number_of_test,x_test.shape[1]*x_test.shape[2])
print("X train flatten",x_train_flatten.shape)
print("X test flatten",x_test_flatten.shape)
```

    X train flatten (170, 16384)
    X test flatten (30, 16384)



```python
x_train = x_train_flatten.T
x_test = x_test_flatten.T
y_test = y_test.T
y_train = y_train.T
print("x train: ",x_train.shape)
print("x test: ",x_test.shape)
print("y train: ",y_train.shape)
print("y test: ",y_test.shape)
```

    x train:  (16384, 170)
    x test:  (16384, 30)
    y train:  (1, 170)
    y test:  (1, 30)


로지스틱회귀 설정


```python
def initialize_weights_and_bias(dimension):
    w = np.full((dimension,1),0.01)
    b = 0.0
    return w, b

def sigmoid(z):
    y_head = 1/(1+np.exp(-z))
    return y_head

def forward_backward_propagation(w,b,x_train,y_train):
    # forward propagation
    z = np.dot(w.T,x_train) + b
    y_head = sigmoid(z)
    loss = -y_train*np.log(y_head)-(1-y_train)*np.log(1-y_head)
    cost = (np.sum(loss))/x_train.shape[1]
    # backward propagation
    derivative_weight = (np.dot(x_train,((y_head-y_train).T)))/x_train.shape[1]
    derivative_bias = np.sum(y_head-y_train)/x_train.shape[1]
    gradients = {"derivative_weight": derivative_weight,"derivative_bias": derivative_bias}
    return cost,gradients

def update(w, b, x_train, y_train, learning_rate,number_of_iterarion):
    cost_list = []
    cost_list2 = []
    index = []
    
    for i in range(number_of_iterarion):
        
        cost,gradients = forward_backward_propagation(w,b,x_train,y_train)
        cost_list.append(cost)
        
        w = w - learning_rate * gradients["derivative_weight"]
        b = b - learning_rate * gradients["derivative_bias"]
        if i % 100 == 0:
            cost_list2.append(cost)
            index.append(i)
            print ("Cost after iteration %i: %f" %(i, cost))
    
    parameters = {"weight": w,"bias": b}
    plt.plot(index,cost_list2)
    plt.xticks(index,rotation='vertical')
    plt.xlabel("Number of Iterarion")
    plt.ylabel("Cost")
    plt.show()
    return parameters, gradients, cost_list

def predict(w,b,x_test):
    
    z = sigmoid(np.dot(w.T,x_test)+b)
    Y_prediction = np.zeros((1,x_test.shape[1]))

    for i in range(z.shape[1]):
        if z[0,i]<= 0.5:
            Y_prediction[0,i] = 0
        else:
            Y_prediction[0,i] = 1

    return Y_prediction

def logistic_regression(x_train, y_train, x_test, y_test, learning_rate ,  num_iterations):

    dimension =  x_train.shape[0]
    w,b = initialize_weights_and_bias(dimension)

    parameters, gradients, cost_list = update(w, b, x_train, y_train, learning_rate,num_iterations)
    
    y_prediction_test = predict(parameters["weight"],parameters["bias"],x_test)
    y_prediction_train = predict(parameters["weight"],parameters["bias"],x_train)
    
    print("Test Accuracy: {} %".format(round(100 - np.mean(np.abs(y_prediction_test - y_test)) * 100,2)))
    print("Train Accuracy: {} %".format(round(100 - np.mean(np.abs(y_prediction_train - y_train)) * 100,2)))
```

로지스틱 회귀 분석을 실행합니다.
- Test Accuracy: 76.67 %
- Train Accuracy: 98.82 %

나쁘지 않은 결과를 도출했습니다.


```python
logistic_regression(x_train, y_train, x_test, y_test,learning_rate = 0.01, num_iterations = 1500)
```

    Cost after iteration 0: nan
    Cost after iteration 100: 0.283178
    Cost after iteration 200: 0.241930
    Cost after iteration 300: 0.216197
    Cost after iteration 400: 0.196884
    Cost after iteration 500: 0.181392
    Cost after iteration 600: 0.168487
    Cost after iteration 700: 0.157473
    Cost after iteration 800: 0.147912
    Cost after iteration 900: 0.139509
    Cost after iteration 1000: 0.132051
    Cost after iteration 1100: 0.125379
    Cost after iteration 1200: 0.119369
    Cost after iteration 1300: 0.113924
    Cost after iteration 1400: 0.108966



    
![png](output_118_1.png)
    


    Test Accuracy: 76.67 %
    Train Accuracy: 98.82 %


## B. 사진을 낮과 밤, 실내와 실외로 분류하는 다중 레이블 분류 모델을 두 개의 로지스틱 회귀 모델을 이용하여 구현하라.

**훈련데이터 불러오기**
- 깃허브에 사진을 올려놓았습니다.
- 낮과 밤 사진 모두 200장씩 준비했습니다.
- 실내와 실외는 100장씩 준비했습니다.
- 앞에 A과정에서 데이터는 모두 불러왔기 때문에 깃허브를 부르는 작업은 생략했습니다.

실내와 실외 사진도 확인해보겠습니다.


```python
Image.open("/content/ML4_pitures/indoor_train/7109056069_1.jpg")
```




    
![png](output_122_0.png)
    




```python
Image.open("/content/ML4_pitures/outdoor_train/4105061037_4.jpg")
```




    
![png](output_123_0.png)
    




```python
train_day = "/content/ML4_pitures/day_train"
train_night = "/content/ML4_pitures/night_train"
test_day = "/content/ML4_pitures/day_test"
test_night = "/content/ML4_pitures/night_test"
train_indoor = "/content/ML4_pitures/indoor_train"
train_outdoor = "/content/ML4_pitures/outdoor_train"
test_indoor = "/content/ML4_pitures/indoor_test"
test_outdoor = "/content/ML4_pitures/outdoor_test"
image_size = 128
```

이미지를 분석에 좋게 변경합니다.
- daytime
- night
- indoor
- outdoor


```python
for image in tqdm(os.listdir(train_day)): 
    path = os.path.join(train_day, image)
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
    img = cv2.resize(img, (image_size, image_size)).flatten()   
    np_img=np.asarray(img)
    
for image2 in tqdm(os.listdir(train_night)): 
    path = os.path.join(train_night, image2)
    img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
    img2 = cv2.resize(img2, (image_size, image_size)).flatten() 
    np_img2=np.asarray(img2)

for image3 in tqdm(os.listdir(train_indoor)): 
    path = os.path.join(train_indoor, image3)
    img3 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
    img3 = cv2.resize(img3, (image_size, image_size)).flatten() 
    np_img3=np.asarray(img3)
    
for image4 in tqdm(os.listdir(train_outdoor)): 
    path = os.path.join(train_outdoor, image4)
    img4 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
    img4 = cv2.resize(img4, (image_size, image_size)).flatten() 
    np_img4=np.asarray(img4)

plt.figure(figsize=(10,10))
plt.subplot(2, 2, 1)
plt.imshow(np_img.reshape(image_size, image_size))
plt.axis('off')
plt.subplot(2, 2, 2)
plt.imshow(np_img2.reshape(image_size, image_size))
plt.axis('off')
plt.subplot(2, 2, 3)
plt.imshow(np_img3.reshape(image_size, image_size))
plt.axis('off')
plt.subplot(2, 2, 4)
plt.imshow(np_img4.reshape(image_size, image_size))
plt.axis('off')
```

    100%|██████████| 50/50 [00:00<00:00, 531.30it/s]
    100%|██████████| 50/50 [00:00<00:00, 340.67it/s]
    100%|██████████| 80/80 [00:08<00:00,  9.64it/s]
    100%|██████████| 85/85 [00:07<00:00, 11.21it/s]





    (-0.5, 127.5, 127.5, -0.5)




    
![png](output_126_2.png)
    


훈련데이터 설정


```python
def train_data():
    train_data_daytime = [] 
    train_data_night = []
    train_data_indoor = [] 
    train_data_outdoor = []
    for image1 in tqdm(os.listdir(train_day)): 
        path = os.path.join(train_day, image1)
        img1 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img1 = cv2.resize(img1, (image_size, image_size))
        train_data_daytime.append(img1) 
    for image2 in tqdm(os.listdir(train_night)): 
        path = os.path.join(train_night, image2)
        img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img2 = cv2.resize(img2, (image_size, image_size))
        train_data_night.append(img2) 
    for image3 in tqdm(os.listdir(train_indoor)): 
        path = os.path.join(train_indoor, image3)
        img3 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img3 = cv2.resize(img1, (image_size, image_size))
        train_data_indoor.append(img3) 
    for image4 in tqdm(os.listdir(train_outdoor)): 
        path = os.path.join(train_outdoor, image4)
        img4 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img4 = cv2.resize(img4, (image_size, image_size))
        train_data_outdoor.append(img4) 
    
    train_data= np.concatenate((np.asarray(train_data_daytime),np.asarray(train_data_night),
                                np.asarray(train_data_indoor),np.asarray(train_data_outdoor)),axis=0)
    return train_data 
```

테스트데이터 설정


```python
def test_data():
    test_data_daytime = [] 
    test_data_night = []
    test_data_indoor = [] 
    test_data_outdoor = []
    for image1 in tqdm(os.listdir(test_day)): 
        path = os.path.join(test_day, image1)
        img1 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img1 = cv2.resize(img1, (image_size, image_size))
        test_data_daytime.append(img1) 
    for image2 in tqdm(os.listdir(test_night)): 
        path = os.path.join(test_night, image2)
        img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img2 = cv2.resize(img2, (image_size, image_size))
        test_data_night.append(img2)
    for image3 in tqdm(os.listdir(test_indoor)): 
        path = os.path.join(test_indoor, image3)
        img3 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img3 = cv2.resize(img3, (image_size, image_size))
        test_data_indoor.append(img3) 
    for image4 in tqdm(os.listdir(test_outdoor)): 
        path = os.path.join(test_outdoor, image4)
        img4 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) 
        img4 = cv2.resize(img4, (image_size, image_size))
        test_data_outdoor.append(img4) 
    
    test_data= np.concatenate((np.asarray(test_data_daytime),np.asarray(test_data_night),
                               np.asarray(test_data_indoor),np.asarray(test_data_outdoor)),axis=0) 
    return test_data 
```

훈련데이터, 테스트데이터
- train_data
- test_data


```python
train_data = train_data()
test_data = test_data()
```

    100%|██████████| 50/50 [00:00<00:00, 690.76it/s]
    100%|██████████| 50/50 [00:00<00:00, 893.56it/s]
    100%|██████████| 80/80 [00:06<00:00, 12.53it/s]
    100%|██████████| 85/85 [00:07<00:00, 11.24it/s]
    100%|██████████| 50/50 [00:00<00:00, 755.66it/s]
    100%|██████████| 50/50 [00:00<00:00, 840.80it/s]
    100%|██████████| 19/19 [00:01<00:00, 14.14it/s]
    100%|██████████| 15/15 [00:00<00:00, 18.22it/s]


x_data : 정규화한 데이터


```python
x_data=np.concatenate((train_data,test_data),axis=0)
x_data = (x_data-np.min(x_data))/(np.max(x_data)-np.min(x_data))
```


```python
z1 = np.zeros(160)
o1 = np.ones(160)
Y_train = np.concatenate((o1, z1), axis=0)
z = np.zeros(40)
o = np.ones(39)
Y_test = np.concatenate((o, z), axis=0)
```


```python
y_data=np.concatenate((Y_train,Y_test),axis=0).reshape(x_data.shape[0],1)
```


```python
print("X shape: " , x_data.shape)
print("Y shape: " , y_data.shape)
```

    X shape:  (399, 128, 128)
    Y shape:  (399, 1)


train_test_split


```python
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.15, random_state=42)
number_of_train = x_train.shape[0]
number_of_test = x_test.shape[0]
```


```python
x_train_flatten = x_train.reshape(number_of_train,x_train.shape[1]*x_train.shape[2])
x_test_flatten = x_test .reshape(number_of_test,x_test.shape[1]*x_test.shape[2])
print("X train flatten",x_train_flatten.shape)
print("X test flatten",x_test_flatten.shape)
```

    X train flatten (339, 16384)
    X test flatten (60, 16384)



```python
x_train = x_train_flatten.T
x_test = x_test_flatten.T
y_test = y_test.T
y_train = y_train.T
print("x train: ",x_train.shape)
print("x test: ",x_test.shape)
print("y train: ",y_train.shape)
print("y test: ",y_test.shape)
```

    x train:  (16384, 339)
    x test:  (16384, 60)
    y train:  (1, 339)
    y test:  (1, 60)


로지스틱회귀함수


```python
def initialize_weights_and_bias(dimension):
    w = np.full((dimension,1),0.01)
    b = 0.0
    return w, b

def sigmoid(z):
    y_head = 1/(1+np.exp(-z))
    return y_head

def forward_backward_propagation(w,b,x_train,y_train):
    # forward propagation
    z = np.dot(w.T,x_train) + b
    y_head = sigmoid(z)
    loss = -y_train*np.log(y_head)-(1-y_train)*np.log(1-y_head)
    cost = (np.sum(loss))/x_train.shape[1]
    # backward propagation
    derivative_weight = (np.dot(x_train,((y_head-y_train).T)))/x_train.shape[1]
    derivative_bias = np.sum(y_head-y_train)/x_train.shape[1]
    gradients = {"derivative_weight": derivative_weight,"derivative_bias": derivative_bias}
    return cost,gradients

def update(w, b, x_train, y_train, learning_rate,number_of_iterarion):
    cost_list = []
    cost_list2 = []
    index = []
    
    for i in range(number_of_iterarion):
        
        cost,gradients = forward_backward_propagation(w,b,x_train,y_train)
        cost_list.append(cost)
        
        w = w - learning_rate * gradients["derivative_weight"]
        b = b - learning_rate * gradients["derivative_bias"]
        if i % 100 == 0:
            cost_list2.append(cost)
            index.append(i)
            print ("Cost after iteration %i: %f" %(i, cost))
    
    parameters = {"weight": w,"bias": b}
    plt.plot(index,cost_list2)
    plt.xticks(index,rotation='vertical')
    plt.xlabel("Number of Iterarion")
    plt.ylabel("Cost")
    plt.show()
    return parameters, gradients, cost_list

def predict(w,b,x_test):
    
    z = sigmoid(np.dot(w.T,x_test)+b)
    Y_prediction = np.zeros((1,x_test.shape[1]))

    for i in range(z.shape[1]):
        if z[0,i]<= 0.5:
            Y_prediction[0,i] = 0
        else:
            Y_prediction[0,i] = 1

    return Y_prediction

def logistic_regression(x_train, y_train, x_test, y_test, learning_rate ,  num_iterations):

    dimension =  x_train.shape[0]
    w,b = initialize_weights_and_bias(dimension)

    parameters, gradients, cost_list = update(w, b, x_train, y_train, learning_rate,num_iterations)
    
    y_prediction_test = predict(parameters["weight"],parameters["bias"],x_test)
    y_prediction_train = predict(parameters["weight"],parameters["bias"],x_train)
    
    print("Test Accuracy: {} %".format(round(100 - np.mean(np.abs(y_prediction_test - y_test)) * 100,2)))
    print("Train Accuracy: {} %".format(round(100 - np.mean(np.abs(y_prediction_train - y_train)) * 100,2)))
```

로지스틱 회귀 분석을 실행합니다.
- Test Accuracy: 95.0 %
- Train Accuracy: 93.51 %

- 낮과 밤 로지스틱 회귀 분석 -> 낮과 밤, 실내와 실외 로지스틱 회귀분석
 - Test Accuracy: 76.67 % -> Test Accuracy: 95.0 %
 - Train Accuracy: 98.82 % -> Train Accuracy: 93.51 %


```python
logistic_regression(x_train, y_train, x_test, y_test,learning_rate = 0.01, num_iterations = 1500)
```

    Cost after iteration 0: nan
    Cost after iteration 100: 1.009304
    Cost after iteration 200: 0.378971
    Cost after iteration 300: 0.319148
    Cost after iteration 400: 0.291621
    Cost after iteration 500: 0.275098
    Cost after iteration 600: 0.263766
    Cost after iteration 700: 0.255355
    Cost after iteration 800: 0.248779
    Cost after iteration 900: 0.243445
    Cost after iteration 1000: 0.238999
    Cost after iteration 1100: 0.235216
    Cost after iteration 1200: 0.232302
    Cost after iteration 1300: 0.261755
    Cost after iteration 1400: 0.259038



    
![png](output_145_1.png)
    


    Test Accuracy: 95.0 %
    Train Accuracy: 93.51 %


## C. 과제 1에서 구현한 자신의 알고리즘과 사이킷런에서 제공하는 LogisticRegression 모델의 성능을 비교하라. 

과제1에서 규제를 적용하지 않은 로지스틱 회귀분석에서 0.9라는 결과과 나왔습니다. 이제 사이킷런으로 비교해보겠습니다.


```python
X = iris["data"][:, (2, 3)]  # 꽃잎 길이, 꽃잎 넓이
y = iris["target"]
```


```python
from sklearn.linear_model import LogisticRegression
log_reg = LogisticRegression(solver='lbfgs', random_state=42)
log_reg.fit(X,y)
```




    LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                       intercept_scaling=1, l1_ratio=None, max_iter=100,
                       multi_class='auto', n_jobs=None, penalty='l2',
                       random_state=42, solver='lbfgs', tol=0.0001, verbose=0,
                       warm_start=False)



사이킷런에서 제공하는 LogisticRegression을 이용한 결과
- 정확도 : 0.97
 - 과제1 (조기종료 설정 전) -> 사이킷런 사용
 - 0.83 -> 0.97


```python
log_reg.score(X, y)
```




    0.9666666666666667



**나의 결론**

0.14정도 사이킷런이 더 우수했습니다. 또한 사이킷런을 사용했을때 적은 노력으로 결과를 도출할 수 있기 때문에 사이킷런을 사용하는 편이 훨씬 효과적이라고 생각됩니다.


```python

```
